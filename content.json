{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Qing Tian","url":"https://qingtian125.github.io","root":"/"},"pages":[],"posts":[{"title":"剪绳子","slug":"剪绳子","date":"2022-01-19T07:14:50.000Z","updated":"2022-01-19T07:24:06.996Z","comments":true,"path":"2022/01/19/剪绳子/","link":"","permalink":"https://qingtian125.github.io/2022/01/19/%E5%89%AA%E7%BB%B3%E5%AD%90/","excerpt":"","text":"剪绳子 题目链接: 解题思路：对于这种求最值的题目。大部分都是可以用动态规划的方法来解决的。 本题采用动态规划的思路解决。首先明确函数代表的意义。dp[i]表示长度为i的绳子剪出来的最大乘积。其次就是找状态转移方程。这也是最难的一步。对于一段绳子剪出一段长度为1 的乘积不影响。所以J代表剪的长度从2开始考虑，一种情况是剪了之后后面的不剪了乘积为j*(i-j)。一种是剩下的还继续剪，乘积为 j * dp[i-j].两种情况取最大值。还有就是对于不同的J,dp[i]也不一定相同。所以取其中的最大值。 123456789101112class Solution &#123; public int cuttingRope(int n) &#123; int[] dp=new int[n+1]; if(n&lt;=3) return n-1; for(int i=3;i&lt;=n;i++)&#123; for(int j=2;j&lt;i;j++)&#123; dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j])); &#125; &#125; return dp[n]; &#125;&#125;","categories":[],"tags":[]},{"title":"机器人最远到达的格数","slug":"机器人最远到达的格数","date":"2022-01-18T07:07:44.000Z","updated":"2022-01-18T07:13:18.681Z","comments":true,"path":"2022/01/18/机器人最远到达的格数/","link":"","permalink":"https://qingtian125.github.io/2022/01/18/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%9C%80%E8%BF%9C%E5%88%B0%E8%BE%BE%E7%9A%84%E6%A0%BC%E6%95%B0/","excerpt":"","text":"题目链接: (https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/) 解题思路: 和矩阵中的路径类似，都是回溯框架。不过本题和上题不同的地方在于只能从0,0出发。不可以从其他位置出发。本题还要记录能到达的格数，所以到一个格子，就记录一次。还要有一个二维数组记录格子是否访问过，避免重复计数。 12345678910111213141516171819202122class Solution &#123; public int movingCount(int m, int n, int k) &#123; boolean[][] visited=new boolean[m][n]; return backtrack(m,n,0,0,k,visited); &#125; public int backtrack(int m,int n,int rowBegin,int colBegin,int k,boolean[][] visited)&#123; int a=rowBegin/10,a1=rowBegin%10; int b=colBegin/10,b1=colBegin%10; //不合法的情况 if(rowBegin&gt;=m||colBegin&gt;=n||rowBegin&lt;0||colBegin&lt;0||visited[rowBegin][colBegin])&#123; return 0; &#125; if(a+a1+b+b1&gt;k)&#123; return 0; &#125; //做选择 visited[rowBegin][colBegin]=true; return 1+backtrack(m,n,rowBegin+1,colBegin,k,visited)+backtrack(m,n,rowBegin,colBegin+1,k,visited); //这里没有撤销选择，是因为和上题不一样。本题只能从坐标0,0出发，做深度遍历。到最远结束，并不会重新选出发点遍历。 //因为是从0,0出发做深度优先搜索，所以往左，往上是不合法的情况。 &#125;&#125;","categories":[],"tags":[]},{"title":"矩阵中的路径","slug":"矩阵中的路径","date":"2022-01-18T02:39:26.000Z","updated":"2022-01-18T02:56:03.954Z","comments":true,"path":"2022/01/18/矩阵中的路径/","link":"","permalink":"https://qingtian125.github.io/2022/01/18/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"","text":"矩阵中的路径 题目链接:(https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/) 解题思路：本文采用回溯的思路解题。回溯的核心思想就是从选择列表做选择，然后执行，最后撤销选择。首先得明确选择列表，做了选择之后干什么。明确了这些之后题目就变得清晰了。还有些回溯的题目会让你返回所有成功的情况，这时候多加一个变量，寻找成功的时候将成功的情况加进去即可。 ​ 题目中说字母不能重复使用，所以需要一个boolean类型的二维数组visited来记录是否被访问过。本题的选择列表就是未被访问过的那些字符。i,j变量用来循环遍历board网格。还需要一个结束条件，就是当我们在二维网格中找的字符串的长度等于word的长度时，说明我们寻找成功了。寻找的长度用k来记录。其他就是排除一些不合法的情况。 代码如下： 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean exist(char[][] board, String word) &#123; int row=board.length; int col=board[0].length; boolean[][] visited=new boolean[row][col]; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; boolean res= backtrack(board,visited,i,j,word,0); if(res) return true; &#125; &#125; return false; &#125; //回溯 boolean backtrack(char[][] board,boolean[][] visited,int i,int j,String word,int k)&#123; //排除不合法的情况 if(i&lt;0||j&lt;0||i&gt;board.length-1||j&gt;board[0].length-1) return false; //处于i行j列的元素已经被访问过了 if(visited[i][j]) return false; if(board[i][j]!=word.charAt(k)) return false; //寻找成功 if(k==word.length()-1) return true; //做选择 visited[i][j]=true; boolean temp= backtrack(board,visited,i,j-1,word,k+1)|| backtrack(board,visited,i-1,j,word,k+1)|| backtrack(board,visited,i,j+1,word,k+1)|| backtrack(board,visited,i+1,j,word,k+1); //撤销选择 visited[i][j]=false; //最后不要忘记返回结果 return temp; &#125;&#125;","categories":[],"tags":[]},{"title":"数组长度，字符串长度函数","slug":"数组长度，字符串长度函数","date":"2022-01-17T14:36:30.000Z","updated":"2022-01-17T14:38:39.812Z","comments":true,"path":"2022/01/17/数组长度，字符串长度函数/","link":"","permalink":"https://qingtian125.github.io/2022/01/17/%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%E5%87%BD%E6%95%B0/","excerpt":"","text":"数组长度函数：arr.length; 字符串长度函数：s.length() 集合大小：c.size()","categories":[],"tags":[]},{"title":"填补空格和反转链表","slug":"填补空格和反转链表","date":"2022-01-17T01:22:11.000Z","updated":"2022-01-17T01:34:26.837Z","comments":true,"path":"2022/01/17/填补空格和反转链表/","link":"","permalink":"https://qingtian125.github.io/2022/01/17/%E5%A1%AB%E8%A1%A5%E7%A9%BA%E6%A0%BC%E5%92%8C%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"填补空格 题目链接 (https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/) 解题思路：这道题主要考察的就是对基本函数的掌握情况。对于字符串用Stringbuilder函数重新拼接。遍历原字符串，如果遇到空格，就替换。否则就用原来的字符。还要掌握charAt()函数。 代码如下： 12345678910111213class Solution &#123; public String replaceSpace(String s) &#123; StringBuilder sb=new StringBuilder(); for(int i=0;i&lt;s.length();i++)&#123; if(s.charAt(i)==&#x27; &#x27;)&#123; sb.append(&quot;%20&quot;); &#125;else&#123; sb.append(s.charAt(i)); &#125; &#125; return sb.toString(); &#125;&#125; 反转链表 题目链接: (https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/) 解题思路：本题就是反转链表的思想。使用递归来实现反转。但题目要求使用数组来返回结果。所以在递归的时候，用数组来保存结点的值。最后返回数组的结果就可以了。 1234567891011121314151617class Solution &#123; ArrayList&lt;Integer&gt; temp=new ArrayList&lt;&gt;(); public int[] reversePrint(ListNode head) &#123; reverse(head); int[] res=new int[temp.size()]; for(int i=0;i&lt;temp.size();i++)&#123; res[i]=temp.get(i); &#125; return res; &#125; //反转链表 void reverse(ListNode head)&#123; if(head==null) return; reverse(head.next); temp.add(head.val); &#125;&#125; 总结：对于递归的思想。最好不好进递归过程。清楚函数的作用，然后递归的下一步该做什么。这样看递归的问题会清晰一些。","categories":[],"tags":[]},{"title":"剑值01,02","slug":"剑值01-02","date":"2022-01-12T11:26:21.000Z","updated":"2022-01-12T12:16:16.268Z","comments":true,"path":"2022/01/12/剑值01-02/","link":"","permalink":"https://qingtian125.github.io/2022/01/12/%E5%89%91%E5%80%BC01-02/","excerpt":"","text":"剑指01 题目链接：(https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/) 解题思路：对于数组中重复数字问题这道题，考察的是Set这种数据结构，HashSet是一种无序的没有重复元素的结构，用来判断数组中是否有重复元素。 1234567891011121314151617181920class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Set&lt;Integer&gt; res=new HashSet&lt;&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if(res.contains(nums[i])) return nums[i]; res.add(nums[i]); &#125; return -1; &#125;&#125; 剑指02 题目链接：(https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/) 解题思路：本题很容易想到的就是暴力解法。从矩阵的左上角遍历到矩阵的右下角。但是这样的时间复杂度显然很大为0(n*m)。其实这个二维数组是有规律的。从左到右递增，从上到下也是递增的。可以将其旋转。 旋转之后，这样类似于一棵二叉搜索树。从根结点进行查找，如果target值小，则往右查找，反之往左进行查找。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public boolean findNumberIn2DArray(int matrix, int target) &#123; //判断不合法的情况 //if(matrix==null||matrix[0].length==0||matrix.length==0) return false; if(matrix==null||matrix.length==0||(matrix.length==1&amp;&amp;matrix[0].length==0)) return false; int i=0; int j=matrix[0].length-1; while(i&lt;matrix.length&amp;&amp;j&gt;=0)&#123; if(matrixi&lt;target)&#123; i++; &#125;else if(matrixi&gt;target)&#123; j--; &#125;else&#123; return true; &#125; &#125; return false; &#125;&#125; 这里判断不合法情况的时候遇到了一个小问题，上面的那句会报空指针异常的错误 12345678ava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0 at line 4, Solution.findNumberIn2DArray at line 57, DriverSolution.helper at line 84, Driver.main 后来发现对于二维数组为空的判断，需要判断三步。 第一步：数组的首地址为空，即matrix==null。 第二步：判断是否为[],即matrix.length==0 第三步：判断是否为[[]]，这种情况matrix.length==1，但是matrix[0].length==0. 对于本题，因为为整数，所以判断前两步已经够了。","categories":[],"tags":[]},{"title":"两数相加","slug":"两数相加","date":"2022-01-11T07:05:09.000Z","updated":"2022-01-11T07:23:12.505Z","comments":true,"path":"2022/01/11/两数相加/","link":"","permalink":"https://qingtian125.github.io/2022/01/11/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"两数相加 题目描述见链接：(https://leetcode-cn.com/problems/add-two-numbers) 解题思路：两个非负整数相加，相加的和除于10，余数作为新的链表的值，产生的进位加到下一次的运算中。这里两个的链表不一定一样长，对于不一般长的链表，短的链表用0补齐。如果链表最后产生了进位，则将进位补在新链表的末尾。 public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode pre=new ListNode(0); ListNode cur=pre; int carry=0; while(l1!=null||l2!=null)&#123; int temp1=l1==null? 0:l1.val; int temp2=l2==null? 0:l2.val; int sum=temp1+temp2+carry; carry=sum/10; int temp=sum%10; cur.next=new ListNode(temp); cur=cur.next;//这里需要将指针后移，不然你得到的就是一个值，而不是链表。因为每次修改的就是这个结点的值 if(l1!=null)&#123; l1=l1.next; &#125; if(l2!=null)&#123; l2=l2.next; &#125; &#125; if(carry==1)&#123; cur.next=new ListNode(1); &#125; return pre.next; &#125;","categories":[],"tags":[]},{"title":"如何利用hexo和github创建自己的博客","slug":"如何利用hexo和github创建自己的博客","date":"2022-01-04T08:49:32.000Z","updated":"2022-01-04T13:31:57.849Z","comments":true,"path":"2022/01/04/如何利用hexo和github创建自己的博客/","link":"","permalink":"https://qingtian125.github.io/2022/01/04/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"安装Git 从Git官网直接下载安装即可。 安装Hexo 1.Hexo是基于Node.js的，所以需要先安装Node.js。Node.js的下载地址为：https://nodejs.org/en 安装完成后，打开命令行窗口，执行node -v检查是否安装成功。 如果出现版本号，说明安装成功！ 检测npm是否安装成功。 2.安装成功之后，下面执行命令语句来安装Hexo.首先在本地创建一个文件夹来存放你的博客。可以命名为Blog。之后在此文件夹下按住shift建，右击鼠标点击命令行。 在命令行窗口中，运行以下语句。 1npm install -g hexo-cli 安装过程比较久，耐心等待安装完毕。 3.初始化博客 在命令行窗口中运行如下的语句。init 代表初始化，blog是自己取的文件夹名。你也可以取成其他的。 1hexo init blog 4.测试案例 初始化完成之后，接下来我们可以创建一个案例，来观看我们的博客的雏形 首先，运行 1hexo new test_my_site 创建一个名为test_my_site的md文件。然后运行下面的语句 1hexo g hexo g == hexo generate 生成的意思。运行此命令会将你写在本地内容生成到服务器上。运行下面的命令，启动服务预览。 1hexo s 成功运行完上述命令之后，我们就可以打开浏览器访问localhost:4000来观看我们的博客。(hexo默认的端口为4000，可以通过hexo -p +你自己设置的端口号来修改) 部署到网站 上面我们已经在本地将所有的东西准备好了。接下来就需要博客的内容推送到网站上。让更多的人可以访问。首先要做的是修改配置文件中的内容： 在blog（我这里初始化的时候起的名字为blog，你自己初始化的名字是什么，就在你的目录下找到_config.yml）目录下找到 _config.yml这个配置文件，打开配置文件，翻到最后修改deploy为： 其中repo:后面的就是你要将你的博客部署到哪里，我这里部署到github上（如果你没有注册Github的话，参考：https://www.cnblogs.com/xiaogongjin/p/11877614.html） 修改完配置之后，最后安装Git部署插件，输入以下命令： 1npm install hexo-deployer-git --save 至此，所有的准备工作已经完成。接下来你可以编写你的博客。编写完成之后，运行 123hexo clean hexo g hexo d 这三条命令，最后一条hexo d 就是部署的命令。最后打开浏览器，输入你仓库路径。 以本例为例，就是输入rundouble.github.io。 你会发现你的博客已经上线了，可以在网络上被访问了。之后你就可以在你的本地上用命令hexo n “文章名”。创建一篇新的博客。新创建的博客在blog下的source下的_posts中。是一个.md文件。之后可以用编译器打开编写博客内容了，最后上传到网站上。（编写md文件，推荐使用Typora。基本操作的教程可参考这篇文章：https://www.cnblogs.com/hider/p/11614688.html 这样一个个人的博客网站就创建好了。","categories":[],"tags":[]},{"title":"qingtian","slug":"qingtian","date":"2022-01-04T07:04:15.000Z","updated":"2022-01-04T07:58:35.692Z","comments":true,"path":"2022/01/04/qingtian/","link":"","permalink":"https://qingtian125.github.io/2022/01/04/qingtian/","excerpt":"","text":"hello","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-01-04T06:17:47.268Z","updated":"2022-01-04T06:17:47.268Z","comments":true,"path":"2022/01/04/hello-world/","link":"","permalink":"https://qingtian125.github.io/2022/01/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}